# Лабораторная работа по теории графов

Проект для выполнения лабораторных работ по дисциплине "Теория графов". Реализован на Python с использованием объектно-ориентированного подхода.

## Структура проекта

```
graphs/
├── main.py                 # Основной файл для запуска заданий
├── utils/
│   ├── __init__.py
│   ├── graph.py           # Класс Graph для работы с графами
│   └── map.py             # Класс Map для работы с лабиринтами
├── tasks/
│   ├── __init__.py
│   ├── task1.py           # Компоненты связности (DFS/BFS)
│   ├── task2.py           # Поиск циклов
│   ├── task3.py           # Остовное дерево (DFS/BFS)
│   ├── task4.py           # Кратчайшие пути (Дейкстра)
│   ├── task5.py           # Двудольность графа
│   ├── task6.py           # Поиск пути в лабиринте (A*)
│   ├── task7.py           # Минимальное остовное дерево (Крускал)
│   ├── task8.py           # Топологическая сортировка
│   ├── task9.py           # Минимальное остовное дерево (Прим)
│   ├── task10.py          # Алгоритм Флойда-Уоршелла
│   ├── task11.py          # Алгоритм Беллмана-Форда-Мура
│   ├── task12.py          # Поиск пути на карте (A*)
│   ├── task13.py          # Максимальное паросочетание (Кун)
│   ├── task14.py          # Максимальный поток (Форд-Фалкерсон)
│   └── task15.py          # Задача коммивояжёра (муравьиная колония)
└── graph-tests/           # Тестовые данные
    ├── task1/
    ├── task2/
    └── ...
```

## Класс Graph

Универсальный класс для работы с графами и орграфами. Поддерживает три формата входных данных:

1. **Матрица смежности** - квадратная матрица с весами рёбер
2. **Списки смежности** - список смежных вершин для каждой вершины
3. **Список рёбер** - список рёбер в формате "из вершины в вершину"

### Основные методы

- `size()` - количество вершин
- `weight(vertex1, vertex2)` - вес ребра между вершинами
- `is_edge(vertex1, vertex2)` - проверка наличия ребра
- `adjacency_matrix()` - матрица смежности
- `adjacency_list(vertex)` - список смежных вершин
- `list_of_edges(vertex)` - список рёбер
- `is_directed()` - проверка направленности графа

## Запуск программы

### Основной синтаксис

```bash
py main.py <номер_задания> [номер_теста] [опции]
```

### Параметры

- `номер_задания` (обязательный) - номер задания от 1 до 15
- `номер_теста` (опциональный) - конкретный тест (например, 001) или все тесты
- `--algorithm {dfs,bfs}` - алгоритм для задания 1 (по умолчанию: dfs)
- `-i {m,a,e}` - тип входного файла:
  - `m` - матрица смежности (matrix)
  - `a` - списки смежности (adjacency_list)
  - `e` - список рёбер (list_of_edges)
- `-s, --show-result` - показать подробный результат и эталон

### Примеры использования

```bash
# Задание 1, все тесты
py main.py 1

# Задание 1, тест 001
py main.py 1 001

# Задание 1, тест 001, алгоритм BFS
py main.py 1 001 --algorithm bfs

# Задание 1, все тесты, только списки смежности
py main.py 1 -i a

# Задание 1, тест 001, список рёбер, с выводом результата
py main.py 1 001 -i e -s

# Задание 15, тест 001 (задача коммивояжёра)
py main.py 15 001 -s
```

## Реализованные задания

### Задание 1: Поиск компонент связности
**Алгоритмы:** DFS/BFS для поиска компонент связности графа и слабой связности в орграфе.

**Входные данные:** Граф в любом из трёх форматов
**Выходные данные:** Информация о связности и список компонент

### Задание 2: Поиск циклов
**Алгоритм:** DFS с отслеживанием обратных рёбер
**Входные данные:** Граф
**Выходные данные:** Наличие циклов и их количество

### Задание 3: Остовное дерево
**Алгоритмы:** DFS/BFS для построения остовного дерева
**Входные данные:** Связный граф
**Выходные данные:** Рёбра остовного дерева

### Задание 4: Кратчайшие пути (Дейкстра)
**Алгоритм:** Алгоритм Дейкстры
**Входные данные:** Взвешенный граф без отрицательных рёбер
**Выходные данные:** Кратчайшие расстояния от стартовой вершины

### Задание 5: Двудольность графа
**Алгоритм:** Раскраска графа в два цвета
**Входные данные:** Граф
**Выходные данные:** Является ли граф двудольным и разбиение на доли

### Задание 6: Поиск пути в лабиринте
**Алгоритм:** A* с различными эвристиками
**Входные данные:** Лабиринт в виде матрицы высот
**Выходные данные:** Длина кратчайшего пути и сам путь

### Задание 7: Минимальное остовное дерево (Крускал)
**Алгоритм:** Алгоритм Крускала с системой непересекающихся множеств
**Входные данные:** Взвешенный неориентированный граф
**Выходные данные:** Вес минимального остовного дерева и его рёбра

### Задание 8: Топологическая сортировка
**Алгоритм:** DFS с отслеживанием времени выхода
**Входные данные:** Ациклический орграф
**Выходные данные:** Топологический порядок вершин

### Задание 9: Минимальное остовное дерево (Прим)
**Алгоритм:** Алгоритм Прима с приоритетной очередью
**Входные данные:** Взвешенный неориентированный граф
**Выходные данные:** Вес минимального остовного дерева и его рёбра

### Задание 10: Алгоритм Флойда-Уоршелла
**Алгоритм:** Динамическое программирование для всех пар кратчайших путей
**Входные данные:** Взвешенный граф (может содержать отрицательные рёбра, но не циклы)
**Выходные данные:** Матрица кратчайших расстояний между всеми парами вершин

### Задание 11: Алгоритм Беллмана-Форда-Мура
**Алгоритм:** Поиск кратчайших путей с возможностью отрицательных рёбер
**Входные данные:** Взвешенный граф
**Выходные данные:** Кратчайшие расстояния или обнаружение отрицательного цикла

### Задание 12: Поиск пути на карте
**Алгоритм:** A* с различными эвристиками (манхэттен, чебышев, евклидова)
**Входные данные:** Карта в виде матрицы высот
**Выходные данные:** Длина пути между двумя точками

### Задание 13: Максимальное паросочетание
**Алгоритм:** Алгоритм Куна для двудольных графов
**Входные данные:** Двудольный граф
**Выходные данные:** Размер максимального паросочетания и его рёбра

### Задание 14: Максимальный поток
**Алгоритм:** Алгоритм Форда-Фалкерсона с BFS
**Входные данные:** Сеть с источником и стоком
**Выходные данные:** Величина максимального потока и матрица потоков

### Задание 15: Задача коммивояжёра
**Алгоритм:** Муравьиная колония (Ant Colony Optimization)
**Входные данные:** Полный взвешенный граф
**Выходные данные:** Длина кратчайшего гамильтонова цикла и путь

## Форматы входных файлов

### Матрица смежности
```
6
0 1 0 0 1 0 
1 0 1 0 0 0 
0 1 0 0 0 0 
0 0 0 0 0 1 
1 0 0 0 0 0 
0 0 0 1 0 0 
```

### Списки смежности
```
6
2:1 5:1 
1:1 3:1 
2:1 
6:1 
1:1 
4:1 
```

### Список рёбер
```
6
1 2 1
1 5 1
2 1 1
2 3 1
3 2 1
4 6 1
5 1 1
6 4 1
```

## Особенности реализации

- **Итеративные алгоритмы** - используются для избежания переполнения стека
- **Автоматическое увеличение лимита рекурсии** - для больших графов
- **Поддержка всех форматов входных данных** - матрица, списки смежности, список рёбер
- **Корректная обработка орграфов** - отдельная логика где необходимо
- **Оптимизированные алгоритмы** - использование эффективных структур данных
- **Гибкая система тестирования** - поддержка различных типов тестов

## Требования

- Python 3.7+
- Стандартные библиотеки Python (typing, collections, sys, os, argparse, heapq, math, random)

## Разработка

Для добавления нового задания:

1. Создайте файл `tasks/taskN.py`
2. Реализуйте функцию `solve_task(graph: Graph, **kwargs) -> str`
3. Добавьте тестовые данные в `graph-tests/taskN/`

Функция `solve_task` должна принимать объект `Graph` и возвращать строку с результатом в требуемом формате.

### Пример структуры taskN.py:
```python
from utils import Graph

def solve_task(graph: Graph, **kwargs) -> str:
    """
    Решает задачу N.
    
    Args:
        graph: объект графа
        **kwargs: дополнительные параметры
        
    Returns:
        str: результат в требуемом формате
    """
    # Ваша реализация здесь
    return result
``` 